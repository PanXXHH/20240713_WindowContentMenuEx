import pandas as pd
from mysupport.Pather.Pather3 import Pather
import datetime
import os
import re


def getlastfile(path: str, type: str) -> str:
    _path = Pather(path)
    if not _path.exists():
        raise ValueError("路径不存在")

    # print(path.str())
    for root, dirs, files in os.walk(str(_path)):
        break

    files = [filename for filename in files if re.match(
        r"^\d{4}-\d{2}-\d{2}"+f"\.{type}$", filename)]
    if len(files) == 0:
        return None
    files.sort(reverse=True)
    return str(_path(files[0]))


def read_all_sheets(filename: str) -> dict[str, pd.DataFrame]:
    xls = pd.ExcelFile(filename)
    sheet_names = xls.sheet_names

    all_data = {}
    for sheet in sheet_names:
        all_data[sheet] = pd.read_excel(xls, sheet_name=sheet)

    return all_data


def time_to_seconds(t):
    return t.hour * 3600 + t.minute * 60 + t.second


def seconds_to_time(seconds):
    hours = seconds // 3600
    seconds %= 3600
    minutes = seconds // 60
    seconds %= 60
    return datetime.time(hours, minutes, seconds)


def add_times(time1: datetime.time, time2: datetime.time):
    add_in_seconds = time_to_seconds(time1) + time_to_seconds(time2)
    return seconds_to_time(add_in_seconds)


def distribute_minutes(input_time, num_periods):
    total_minutes = input_time.hour * 60 + input_time.minute
    per_variable, remainder = divmod(total_minutes, num_periods)

    distribution = []
    for i in range(num_periods):
        if i < remainder:
            minutes = per_variable + 1
        else:
            minutes = per_variable
        distribution.append(datetime.time(minutes // 60, minutes % 60))

    return distribution


def subtract_times(time1, time2):
    difference_in_seconds = time_to_seconds(time1) - time_to_seconds(time2)
    # Handle negative results
    if difference_in_seconds < 0:
        difference_in_seconds += 24*3600
    return seconds_to_time(difference_in_seconds)


def str_to_time(time_str_or_obj):
    # 如果已经是datetime.time类型，则直接返回
    if isinstance(time_str_or_obj, datetime.time):
        return time_str_or_obj

    # 否则，尝试从字符串解析
    h, m, s = map(int, time_str_or_obj.split(':'))
    return datetime.time(h, m, s)


def 获取时系数(rules_data, 行为: str) -> int:
    for task in rules_data:
        if task['行为'] == 行为:
            return int(task['时系数'])
    return -1


# 函数定义：检查累计未执行时间是否超过目标时间
def check_cache_list_of_dicts(cache_list_of_dicts: list[dict], target_time: datetime.time) -> bool:
    for cache in cache_list_of_dicts:
        if cache['累计未执行时间'] >= target_time:
            return True
    return False


