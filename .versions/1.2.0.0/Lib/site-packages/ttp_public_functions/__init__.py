from . import support
from . import config as _config
from mysupport.PopupWindowGenerator._2 import PopupWindowGenerator
import pandas as pd
from mysupport.Pather.Pather3 import Pather
import datetime
# import os
# import shutil
# import re
import subprocess

PACKAGE_NAME = "ttp_public_functions"

__version__ = "1.0.0"


@_config.添加配时文件
def 添加配时文件(path: str, config: dict = {}):

    # 初始化文件路径处理工具
    local_pather = Pather(path)
    # 获取当前日期和时间
    now = datetime.datetime.now()
    # 根据当前日期生成文件名
    filename = "%s.xlsx" % now.strftime(r"%Y-%m-%d")

    # 如果该日期的文件已经存在
    if local_pather(filename).exists():
        # 打开文件
        subprocess.run(["start", "", local_pather(filename).str()], shell=True)
        return

    # 如果文件不存在，创建一个弹出窗口询问用户的时间输入
    pwg = PopupWindowGenerator(buttons=['确定', '取消'])
    pwg.add_input_element(datetime.time(0, 30, 0), "分配时间")
    event, values = pwg.popup()

    # 如果用户点击取消，直接返回
    if event == "取消":
        return

    # 获取用户输入的时间
    input_time: datetime.time = values[0]
    # 获取最后一个xlsx文件的路径
    lastfile = support.getlastfile(local_pather.str(), "xlsx")

    # 检查是否存在一个名为 "RULES.xlsx" 的规则文件
    if not local_pather("RULES.xlsx").exists():
        # PopupWindowGenerator("RULES.xlsx 文件不存在!").popup()
        raise ValueError("RULES.xlsx 文件不存在!")

    # 从 "RULES.xlsx" 中读取所有表单的数据
    rules_sheets_data = support.read_all_sheets(
        local_pather("RULES.xlsx").str())
    # 提取‘Index’表单的数据
    rules_index_data: list[str, dict] = rules_sheets_data['Index'].to_dict(
        orient='records')

    rules_num_periods = rules_sheets_data['Index']['时系数'].sum()
    print(support.distribute_minutes(input_time, rules_num_periods))
    # return

    new_data = []
    # 根据输入时间过滤规则数据
    for i in rules_index_data:
        if input_time >= i["最小执行时间"]:
            new_data.append(i)

    # 检查新数据是否为空
    if new_data == []:
        raise ValueError("数据表为空或分配时间小于所有任务最小分配时间")

    # 如果没有前一个Excel文件
    if lastfile is None:

        # 为新任务计算累计未执行时间
        new_cache_list_of_dicts = []
        for task in new_data:
            i = {"行为": task['行为'],
                 '累计未执行时间': support.seconds_to_time(support.time_to_seconds(input_time) * int(task['时系数']))}
            new_cache_list_of_dicts.append(i)

        # 确保每个任务的累计未执行时间都大于或等于输入时间
        while not support.check_cache_list_of_dicts(new_cache_list_of_dicts, input_time):
            for cache in new_cache_list_of_dicts:
                cache['累计未执行时间'] = support.add_times(
                    cache['累计未执行时间'], support.seconds_to_time(support.time_to_seconds(input_time) * int(support.获取时系数(new_data, cache['行为']))))

        # 查找累计未执行时间超过输入时间的任务
        found = -1
        for index, cache in enumerate(new_cache_list_of_dicts):
            if cache['累计未执行时间'] >= input_time:
                cache['累计未执行时间'] = support.subtract_times(
                    cache['累计未执行时间'], input_time)
                found = index
                break

        # 将数据转换为DataFrame格式
        cache_df = pd.DataFrame(new_cache_list_of_dicts)
        index_list_of_dicts = []
        nowtime = now.time()
        anchor_time = support.add_times(nowtime, input_time)
        i = {"行为": new_cache_list_of_dicts[found]['行为'],
             '实际所得时间': input_time,
             '完成任务时间': anchor_time}
        index_list_of_dicts.append(i)
        index_df = pd.DataFrame(index_list_of_dicts)

        # 保存数据到新的Excel文件
        with pd.ExcelWriter(local_pather(filename).str()) as writer:
            index_df.to_excel(writer, sheet_name="Index", index=False)
            cache_df.to_excel(writer, sheet_name="Cache", index=False)

    else:
        # 如果存在前一个Excel文件
        # 从上一个Excel文件中继承“Cache”数据
        last_cache_df = pd.read_excel(lastfile, sheet_name="Cache")
        last_cache_df['累计未执行时间'] = last_cache_df['累计未执行时间'].apply(
            support.str_to_time)
        new_cache_list_of_dicts = last_cache_df.to_dict(orient='records')
        # Step 1: Create a set of behaviors from rules_index_data
        rules_behaviors = set([item['行为'] for item in rules_index_data])

        # Step 2: Create a new list containing only behaviors present in rules_index_data
        # 计算不在 rules_behaviors 的任务的累计未执行时间之和（以秒为单位）
        _new_cache_list_of_dicts = []

        total_extra_time = 0
        for item in new_cache_list_of_dicts:
            if item['行为'] not in rules_behaviors:
                total_extra_time += support.time_to_seconds(item['累计未执行时间'])
            else:
                _new_cache_list_of_dicts.append(item)

        # 移除不在 rules_behaviors 的任务

        new_cache_list_of_dicts = list(_new_cache_list_of_dicts)
        num_tasks = len(new_cache_list_of_dicts)
        time_to_distribute = total_extra_time / num_tasks if num_tasks > 0 else 0

        # 平均分配时间给每一个在 rules_behaviors 的任务
        for item in new_cache_list_of_dicts:
            new_time = support.time_to_seconds(
                item['累计未执行时间']) + time_to_distribute
            print(new_time)
            item['累计未执行时间'] = support.seconds_to_time(int(new_time))

        # print(new_cache_list_of_dicts)
        current_behaviors = set([item['行为']
                                for item in new_cache_list_of_dicts])
        # print(current_behaviors)
        for task in new_data:
            if task['行为'] not in current_behaviors:
                i = {"行为": task['行为'],
                     '累计未执行时间': datetime.time(0, 0, 0)}
                new_cache_list_of_dicts.append(i)

        # 确保每个任务的累计未执行时间都大于或等于输入时间
        # print(new_cache_list_of_dicts)
        while not support.check_cache_list_of_dicts(new_cache_list_of_dicts, input_time):
            for cache in new_cache_list_of_dicts:
                cache['累计未执行时间'] = support.add_times(
                    cache['累计未执行时间'], support.seconds_to_time(support.time_to_seconds(input_time) * int(support.获取时系数(new_data, cache['行为']))))

        # 查找累计未执行时间超过输入时间的任务
        found = -1
        for index, cache in enumerate(new_cache_list_of_dicts):
            if cache['累计未执行时间'] >= input_time:
                cache['累计未执行时间'] = support.subtract_times(
                    cache['累计未执行时间'], input_time)
                found = index
                break

        # 将数据转换为DataFrame格式
        cache_df = pd.DataFrame(new_cache_list_of_dicts)
        index_list_of_dicts = []
        nowtime = now.time()
        anchor_time = support.add_times(nowtime, input_time)
        i = {"行为": new_cache_list_of_dicts[found]['行为'],
             '实际所得时间': input_time,
             '完成任务时间': anchor_time}
        index_list_of_dicts.append(i)
        index_df = pd.DataFrame(index_list_of_dicts)

        # 保存数据到新的Excel文件
        with pd.ExcelWriter(local_pather(filename).str()) as writer:
            index_df.to_excel(writer, sheet_name="Index", index=False)
            cache_df.to_excel(writer, sheet_name="Cache", index=False)

    subprocess.run(["start", "", local_pather(filename).str()], shell=True)

# 添加配时文件(r"G:\Program Data\ONEDRIVE2023\MY\OneDrive - PANSCLOUD\MYCLOUDDRIVE\CLOUD_MYAPPS\WindowContentMenuEx(MYTOOL)\.versions\1.1.8.4\稳定版（保留3个月）\Lib\site-packages\ttp_smart_public\.sandbox")
